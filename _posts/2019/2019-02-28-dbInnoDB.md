---
layout: post
title: MySql之InnoDB
tags:
- mySql
categories: database
description: MySql之InnoDB
---
## InnoDB
nnoDB是一个负责表中的数据存取的存储引擎。他决定了数据库的存储结构和索引结构。  
由于磁盘的IO是非常慢的，当我们从磁盘加入一条数据或者向磁盘存入一条数据都很耗时，所以InnoDB并不会一条一条的存取数据，而是按页存取。而一页的大小是16kb  

<!-- more -->

## MySQL三大搜索引擎  
**MyiSAM**：节省数据库空间，当数据读操作远远大于修改删除时，使用该引擎，不支持事务，只支持行锁，不支持表锁，不支持外键  
**innoDB**：支持事务，支持行锁，表锁。当数据的修改较多的时候，使用该引擎  
**MEMORY**： 记录只存储在内存中，速度快，存放的是临时性，非永久的数据  
## InnoDB行格式
一般向数据表插入数据是按照记录为单位的，也就是所谓的行。这些记录在磁盘的存放方式也被称为行格式或者记录格式。现在主要有四种行格式，分别是Compact、Redundant、Dynamic和Compressed行格式。  
行格式可以在创建或修改表时指定  
```
	CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
	ALTER TABLE 表名 ROW_FORMAT=行格式名称
```
如下为创建一个表的完整语句  
```
	CREATE TABLE record_format_demo (
		c1 VARCHAR(10),
		c2 VARCHAR(10) NOT NULL,
		c3 CHAR(10),
		c4 VARCHAR(10)
	) CHARSET=ascii ROW_FORMAT=COMPACT;
```
在创建表时指定了行格式就是Compact，还指定了这个表的字符集为ascii。  
ascii不能表示汉字，一个字符占一个字节。  
### COMPACT行格式
Compact行格式如下：  
![Compact行格式](\assets\img\innoDB_1.webp)  
他分为两个部分，额外信息和真实数据。  
#### 额外信息   
##### 变长字段长度列表  
MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、各种TEXT类型，各种BLOB类型。这个表就是把所有变长类型的列的长度都存放在记录的开头部位形成一个列表，按照列的顺序逆序存放。  
准备：  
在上述所建表中添加记录  
```
	INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);
```
第一条记录中的变长字段的长度列表：  
![长度列表](\assets\img\innoDB_2.jpg)  
ascii字符集每个字符只需要1个字节来进行编码，所以每个字符的个数就是他的内容长度  
第二条同样  
所以两条记录的存储格式如下：  
![Compact行格式](\assets\img\innoDB_3.webp)  
##### NULL值列表  
列中为null的数据不会放入真实数据中而是放在null值列表中。Null值列表用一个字节表示。其中每个二进制表示一个允许为null的字段，字段为null则为1，否则为0。二进制位按照列的顺序逆序排列  
表record_format_demo只有3个允许为NULL的列，对应3个二进制位，不足一个字节，所以在字节的高位补0，效果就是这样：  
![NULL值列表](\assets\img\innoDB_4.webp)  
两条记录在填充了NULL值列表后的存储格式如下：  
![Compact行格式](\assets\img\innoDB_5.webp)  
##### 记录头信息  
记录头信息由5个字节组成。包含一下信息：  
![记录头信息](\assets\img\innoDB_6.png)  
**delete_mask**  
这个属性标记着当前记录是否被删除，被删除的记录不会在页中删除而是被标记。占用1个二进制位，值为0的时候代表记录并没有被删除，为1的时候代表记录被删除掉了。如果标记为1时有新的主键相同的记录插入到表中可以覆盖这条记录。  
**min_rec_mask**  
这个属性标记该记录是否为B+树的非叶子节点中的最小记录，用作索引  
**n_owned**  
innoBD将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。每个组的最后一条记录的头信息中的n_owned表示组内共有几条记录。  
**heap_no**  
这个属性表示当前记录在本页中的位置。这是根据主键大小排序的。InnoDB会在页中建立两条虚拟记录，最小记录和最大记录，最小记录位置为0，最大记录位置为1，后面才是具体的用户记录。 
最小记录和最大记录放在页的Infimum + Supremum的部分。  
**record_type**  
记录一共有四个类型：  
普通用户记录：0  
B+树非叶节点记录：1（B+树的非叶子节点记录存储的是目录项记录，叶子节点记录就是普通用户记录）  
最小记录：2  
最大记录：3  
**next_record**  
记录在页中是单向链表  
从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比如一条记录的next_record为15，则从第一条记录的地址处向后移动15就是下一条记录的地址。其中最大记录的next_record等于0  
#### 真实数据  
![真实数据信息](\assets\img\innoDB_7.jpg)  
其中 row_id 只有在表没有定义主键的时候才会为记录添加，相当于MySQL服务器帮我们来添加一个主键  
#### 行溢出数据  
##### VARCHAR最多能存储的数据
VARCHAR(M)类型的列最多可以占用65535个字节。但是如果我们使用ascii字符集（一个字符一个字节），VARCHAR(65535)存储65535个字符会报错数据太大的错误  
MySQL对一条记录占用的最大存储空间是有限制的，除了BLOB或者TEXT类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。  
如果该VARCHAR类型的列没有NOT NULL属性，那最多只能存储65532个字节的数据，因为变长字段长度列表的长度需要占用2个字节，NULL值标识需要占用1个字节。  
##### 行溢出  
但是一个页的大小是16kb，也就是16384字节，而VARCHAR却能最多存储65532个字节，这就导致一个页放不下一条记录的情况，在Compact和Reduntant行格式中，这时候就会把真实的数据分散存放在几个连续的表中。在本记录的真实数据处只会存储该列的前786个字节的数据和一个指向其他页的地址，从而可以找到剩余数据所在的页。这个过程叫做行溢出。  
### Dynamic和Compressed
MySQL版本是5.7，它的默认行格式就是Dynamic。这俩行格式和Compact行格式基本相同，只不过在处理行溢出数据时不一样，它们不会在记录的真实数据处存储字符串的前768个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。  
Compressed行格式和Dynamic不同的一点是，Compressed行格式会把存储到其他页面的数据采用压缩算法进行压缩，以节省空间。  
### CHAR(M)列的存储格式  
对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时（如ascii），该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时（如utf-8），该列占用的字节数也会被加到变长字段长度列表。  
## InnoDB页结构
InnoDB用于存放记录的页也叫做数据页。一个数据页有16kb，其中的具体结构为:  
![InnoDB页结构](\assets\img\innoDB_8.webp)  
其中每个部分的含义如下：  
![结构含义](\assets\img\innoDB_9.jpg)  
插入记录过程：  
![插入记录过程](\assets\img\innoDB_10.webp)  
### 页目录Page Directory  
在数据页中按照主键查找记录的方法是通过目录进行二分查询  
在之前已经说过记录是按照主键大小按位置存放的，然后再将记录进行了分组，每个组的最后一条记录的头信息中的n_owned表示组内共有几条记录。  
对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间  
将每个组的最后一条记录的地址偏移量按顺序存储起来，每个地址偏移量也被称为一个槽（英文名：Slot）。这些地址偏移量都会被存储到靠近页的尾部的地方，页中存储地址偏移量的部分也被称为Page Directory  
结构如下：  
![结构](\assets\img\innoDB_11.webp)  
在一个数据页根据主键查找一条数据的过程：  
通过二分法确定该记录所在的槽  
通过记录的next_record属性组成的链表遍历查找该槽中的各个记录  
### Page Header  
页的描述信息：  
![描述信息](\assets\img\innoDB_12.jpg)  
部分字段解释：  
**FIL_PAGE_SPACE_OR_CHKSUM：**这个代表当前页面的校验和（checksum）。对于一个很长很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。  
**FIL_PAGE_OFFSET：**每一个页都有一个单独的页号，InnoDB通过页号来可以唯一定位一个页。  
**FIL_PAGE_TYPE:**这个代表当前页的类型 InnoDB为了不同的目的而把页分为不同的类型，存放记录的数据页的类型其实是FIL_PAGE_INDEX，也就是所谓的B+树叶子节点，
**FIL_PAGE_PREV和FIL_PAGE_NEXT:**数据页其实是个双向链表。FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，数据页是有这两个属性的，表
**File Trailer:**
我们知道InnoDB存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步的途中中断了怎么办？为了防止这种情况，InnoDB在每个页的尾部都加了一个File Trailer部分，这个部分由8个字节组成，可以分成2个小部分：  
前四个字节代表页的校验和  
这个部分是和File Header中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的，反之意味着同步中间出了错。  
后四个字节代表日志序列位置（LSN）。这个部分也是为了校验页的完整性的。  
## MySQL的索引  
页之间的结构是双向链表，记录之间的结构是单向链表  
**目录项记录**：为了建立页与页之间的目录，MySQL设计了和普通记录类似的目录项记录，存放了主键和页号两个列  
如下图是MySQL的存储结构（其中简化了记录结构，第一行表示record_type，第二行表示next_record，剩下的行是其他普通记录字段）  
![聚簇索引](\assets\img\innoDB_13.webp)  
这是一种树结构，叫B+树。只有叶子节点存放的是用户记录，其他都是目录记录。查找页和页内记录都可以通过二分法定位。  
### 聚簇索引  
具有下面这两种特性的B+树称为聚簇索引  
1，	使用记录主键值的大小进行记录和页的排序（页内的记录是按照主键的大小顺序排成一个单向链表。各个存放用户记录的页也是根据页中记录的主键大小顺序排成一个双向链表。）  
2，	B+树的叶子节点存储的是完整的用户记录  
InnoDB存储引擎会自动的为我们创建聚簇索引，这既是索引也是数据。  
### 二级索引  
聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。  
同样我们可以建立以其他字段值进行排序的B+树，和聚簇索引不同的是这种树的叶子节点并不是完整的用户记录，只有排序列和主键列  
如下图：  
![二级索引](\assets\img\innoDB_14.webp)  
也就是说我们找到二级索引后还要根据主键在聚簇索引中再查找一遍完整的用户记录。这个过程也被称为回表。  
### 联合索引  
可以同时以多个列的大小作为排序规则，也就是同时为多个列建立一个索引，同样联合索引的叶子节点的记录中只包含排序的列和主键，要进行回表。  
步骤：  
先把各个记录和页按照c2列进行排序。  
在记录的c2列相同的情况下，采用c3列进行排序。  
![联合索引](\assets\img\innoDB_15.webp)  
## MyISAM的索引方案  
MyISAM的索引方案虽然也使用B+树，但是却将索引和数据分开存储。  
将表中的记录按照插入时间顺序的存储在一块存储空间上，我们可以通过行号而快速访问到一条记录。  
MyISAM会单独为表的主键创建一个B+树索引，只不过在B+树的叶子节点中存储的不是完整的用户记录，而是主键值 + 行号的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录  
所以MyISAM中建立的索引全部都是二级索引，需要进行两次查询。  
## Mysql索引创建原则
InnoDB和MyISAM会自动为主键或者声明为UNIQUE的列去自动建立B+树索引，但是如果我们想为其他的列建立索引就需要我们显式的去指明






