---
layout: post
title: 深入了解NIO
tags:
- io
categories: java
description: 深入了解NIO
---
## NIO( non-blocking IO）  
指jdk1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供缓存支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。

<!-- more -->

## IO核心
- 在传统的IO编程中最为核心的概念是流。一个流要么是输入流要么是输出流，不可能两者同时都是。  
- 在使用传统的面向流的编程时，应用程序会直接参与IO的读写操作，并且程序会**阻塞**到某个方法上直到数据全部准备就绪，或者**不断轮询**直到数据全部准备就绪  
## NIO核心  
- NIO主要有Selector ，Channel与Buffer三个核心。  
- 而且NIO不再面向流编程，而是面向缓冲区buffer（有堆外内存DirectByteBuffer和堆内内存HeapByteBuffer，堆外内存可以实现零拷贝）编程。所有的数据的读写都是通过buffer实现  
- 在NIO中应用程序不参与IO的读写操作，而是由操作系统将数据加载到缓冲区，当加载完成后会通知客户端读取信息（回调）  
- Channel类似传统IO中的流，是读取或者写入数据的对象。与流不同的是Channel是双向的，一个Channel既可以读也可以写；我们对数据的读写都是通过buffer进行的，并不能直接通过操作Channel写入或者获取数据  
- 网络channel可以与多路复用器结合起来，有多种的状态位，方便多路复用器去识别。  
- 通道分为两类 ： 一类是网络读写的 SelectableChannel 一类事用于文件操作的FileChannel 我们使用SocketChannel和ServerSocketChannel都是SelectableChannel的子类  
## NIO读取文件  

```
package com.tantao;
 
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
 
public class NioTest {
 
    public static void main(String[] args) throws IOException{
		//建立通道，将数据读入通道
        FileInputStream fileInputStream = new FileInputStream("Niotest.txt");
        FileChannel fileChannel =fileInputStream.getChannel();
 
		//分配缓存区，再将通道中的数据写入缓存区
        ByteBuffer byteBuffer = ByteBuffer.allocate(512);
        fileChannel.read(byteBuffer);
		
 		//翻转指针，将position指针指向缓存区的头部,limit指针指向数据的末位
        byteBuffer.flip();
		
 		//从缓存区的position开始读取数据
        while(byteBuffer.remaining()>0){
           byte b = byteBuffer.get();
           System.out.println("---:"+(char)b);
        }
 
        fileInputStream.close();
 
 
    }
}

```  
## NIO写数据到文件  
```
package com.tantao;
 
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
 
public class NioTest1 {
    public static void main(String[] args)  throws IOException {
		//建立通道
        FileOutputStream fileOutputStream = new FileOutputStream("Niotest1.txt");
        FileChannel fileChannel =fileOutputStream.getChannel();
		
 		//建立缓冲区 将数据写入缓冲区
        ByteBuffer byteBuffer = ByteBuffer.allocate(512);
        byte[] mess = " hello wrold welcome , nihao".getBytes();
        for (int i = 0; i< mess.length;i++){
            byteBuffer.put(mess[i]);
        }
 		//翻转指针，将position指针指向缓存区的头部,limit指针指向数据的末位
        byteBuffer.flip();
		
		//将数据写入通道
        fileChannel.write(byteBuffer);
		
        fileOutputStream.close();
    }
}
```
## 零拷贝  
#### 传统IO拷贝数据：  
1，jvm通过底层read方法去请求内核空间（切换1次），然后内核空间请求磁盘read数据  
2，磁盘将数据拷贝到内核空间通过DMA直接内存访问，然后从内核空间将数据拷贝到用户空间（切换1次）  
3，再将数据从用户空间拷贝到内核空间（切换1次），内核空间再拷贝到网卡内存，通过网络发送出去（或拷贝到磁盘）。  
4，返回结果。（切换1次）  
磁盘到内核空间的拷贝属于DMA拷贝（DMA即直接内存存取，原理是外部设备不通过CPU而直接与系统内存交换数据）。而内核空间到用户空间则需要CPU的参与进行拷贝，既然需要CPU参与，也就涉及到了内核态和用户态的相互切换。  
这里总共发生了四次拷贝。四次内核态和用户态的切换  
#### NIO零拷贝  
1，jvm通过底层read方法去请求内核空间（切换1次），内核空间请求磁盘read数据  
2，磁盘将数据拷贝到内核空间通过DMA直接内存访问  
3，内核空间的数据再写入到socket缓冲区中  
4，内核空间将socket缓冲区中的数据写入到网络的客户端中  
5，结束返回结果（切换一次）  
这里涉及到了3次数据拷贝，内核空间有两次缓冲区的拷贝。并且内核态和用户态的切换只有两次。  
#### NIO零拷贝升级  
由于内核空间多拷贝了一次写入到socket缓冲区，为了优化这个问题，NIO提出了scatter/gather操作（需要底层的支持）可以减少内核中的拷贝次数。  
#### MappedByteBuffer  
NIO是通过MappedByteBuffer来直接对堆外内存操作而不必拷贝到堆内内存再进行操作。MappedByteBuffer使用mmap技术将文件直接映射到内存并返回一个地址，然后通过这个地址构造MappedByteBuffer对象，并且暴露各种文件操作的API。  
由于MappedByteBuffer申请的是堆外内存，因此不受Minor GC控制，只能在发生Full GC时才能被回收。而DirectByteBuffer改善了这一情况，它是MappedByteBuffer类的子类，同时它实现了DirectBuffer接口，维护一个Cleaner对象来完成内存回收。因此它既可以通过Full GC来回收内存，也可以调用clean()方法来进行回收。  

