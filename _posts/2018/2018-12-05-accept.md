---
layout: post
title: 网络IO
tags:
- io
categories: network
description: tcp三次握手建立连接
---
## IO
IO是计算机上最慢的部分，先不讨论磁盘IO，针对网络编程，我们需要了解的是网络IO。

<!-- more -->

## 三次握手
对于开发，也就是应用层而言，往往只需要调用类似于accept的API就可以建立TCP连接，那么应用层如何与accept交互呢，首先我们需要知道操作系统是如何实现tcp的三次握手  
![三次握手](\assets\img\accept_1.jpg)
图中这两个队列是内核实现的，当服务器绑定、监听了某个端口后，这个端口的SYN队列和ACCEPT队列就建立好了。
1. 客户端使用connect向服务器发起TCP连接，当图中1.1步骤客户端的SYN包到达了服务器后，内核会把这一信息放到SYN队列（即未完成握手队列）中，同时回一个SYN+ACK包给客户端。  
1. 一段时间后，在图中2.1步骤中客户端再次发来了针对服务器SYN包的ACK网络分组时，内核会把连接从SYN队列中取出，再把这个连接放到ACCEPT队列（即已完成握手队列）中。  
1. 而服务器在第3步调用accept时，其实就是直接从ACCEPT队列中取出已经建立成功的连接套接字而已。  
## 阻塞IO与非阻塞IO
现有我们可以来讨论应用层组件：**为何有的应用服务器进程中，会单独使用1个线程，只调用accept方法来建立连接，例如tomcat；有的应用服务器进程中，却用1个线程做所有的事，包括accept获取新连接和IO操作。**  
原因在于：首先，SYN队列和ACCEPT队列都不是无限长度的，它们的长度限制与调用listen监听某个地址端口时传递的backlog参数有关。既然队列长度是一个值，那么，队列会满吗？答案是当然会。
- 如果上图中第1步执行的速度大于第2步执行的速度，SYN队列就会不断增大直到队列满；
- 如果第2步执行的速度远大于第3步执行的速度，ACCEPT队列同样会达到上限。第1、2步不是应用程序可控的，但第3步却是应用程序的行为，比如进程中调用accept获取新连接的代码段长期得不到执行（例如获取不到锁、IO阻塞等）。导致两个队列满了后，就会使客户端不能再建立新连接，引发严重问题。  
所以，如TOMCAT等服务器会使用独立的线程，只做accept获取连接这一件事，以防止不能及时的去accept获取连接。接受到连接之后建立新的线程对连接请求进行处理，如网络io（接收和发送数据）以及一些其他处理。  
**如Nginx等一些服务器，在一个线程内做accept的同时，还会做其他IO等操作的原因在于应用程序可以把listen时设置的套接字设为非阻塞模式**（默认为阻塞模式），这两种模式会导致accept方法有不同的行为。对阻塞套接字，accept行为如下图：  
![阻塞IO](\assets\img\accept_2.jpg)  
这幅图中可以看到，阻塞套接字上使用accept，第一个阶段是等待ACCEPT队列不为空的阶段，它耗时不定，由客户端是否向自己发起了TCP请求而定，可能会耗时很长。  
对非阻塞套接字，accept会有两种返回，如下图：  
![阻塞IO](\assets\img\accept_3.jpg)  
非阻塞套接字上的accept，不存在等待ACCEPT队列不为空的阶段，它要么返回成功并拿到建立好的连接，要么返回失败。  
所以，企业级的服务器进程中，若某一线程既使用accept获取新连接，又继续在这个连接上读、写字符流，那么，这个连接对应的套接字通常要设为非阻塞。原因如上图，**即使accept队列为空调用accept也不会长期占用所属线程的CPU时间片等待客户端建立连接，使得线程能够及时的做其他工作**  


